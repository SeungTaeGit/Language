# 목표
자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.
<br>

## 학습할 것 (필수)
- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락
<br>


### Thread 클래스와 Runnable 인터페이스
---
  #### Thread 및 Process
  - **Thread** : Process 위에서 Memory, Resource를 할당받아 작동되는 것.
    - 위키 : 스케줄러에 의해 독립적으로 관리되는 프로그래밍된 명령의 가장 작은 실행 단위.
  - **Process** : 현재 실행 중인 프로그램.
    - 모든 Process는 적어도 1개 이상의 Thread가 존재.
  <p align="center"><img src="https://github.com/SeungTaeGit/Language/assets/129585999/cb91ed54-022b-42a6-b26f-7ccb76a9f1c1"></p>
<br>

  #### Thread 생성
  - **Thread 클래스 상속** : Thread 클래스를 상속받고, `run` 메소드를 오버라이딩 및 로직 구현.
> **`run` 메소드** : Thread의 실행 코드가 작성되는 메소드.

  - **Runnable 인터페이스 구현** : Runnable 인터페이스를 구현하고, `run` 메소드를 오버라이딩 및 로직 구현.
<br>

  #### Thread 클래스 상속
  - Thread 클래스를 상속받고, `run` 메소드를 오버라이딩 및 로직 구현.

  **유형**
  ```java
  class 쓰레드명 extends Thread {  // 클래스 정의.

    @Override                     // Thread 클래스의 run 메소드 오버라이딩.
    public void run() {
        // 구현부
    }
  }
  ```
  
  **For example**
  ```java
  public class ThreadRobot extends Thread {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
        System.out.println("Robot Thread");
    }
  }
  ```
> **`getName()` 메소드** : Thread의 이름을 반환하는 메소드.
<br>

  #### Runnable 인터페이스 구현
  - Runnable 인터페이스를 구현하고, `run` 메소드를 오버라이딩 및 로직 구현.
  - 보통의 경우, **다중 상속 방지**를 위해 Runnable 인터페이스를 구현하는 방법을 선호.

  **유형**
  ```java
  class 쓰레드명 implements Runnable {  // 클래스 정의.

    @Override                          // Thread 클래스의 run 메소드 오버라이딩.
    public void run() {
        // 구현부
    }
  }
  ```
  
  **For example**
  ```java
  public class ThreadRobot implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
        System.out.println("Robot Thread");
    }
  }
  ```
<br>


### 쓰레드의 상태
---
<p align="center"><img src="https://github.com/SeungTaeGit/Language/assets/129585999/546d3a56-5d7f-45eb-9d0c-01bcd7fa97c3"></p>

  - **쓰레드의 기본 주기** : `상태 NEW (생성)` → `상태 RUNNABLE (실행대기)` → `실행` → `상태 TERMINATED (소멸)`
<table>
<thead>
  <tr>
    <th colspan="2">상태</th>
    <th>설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>New</td>
    <td>객체 생성</td>
    <td>쓰레드 객체 생성 후 start() 메소드가 실행되지 않은 상태.</td>
  </tr>
  <tr>
    <td>Runnable</td>
    <td>실행</td>
    <td>실행 상태.</td>
  </tr>
  <tr>
    <td>Terminated</td>
    <td>종료</td>
    <td>쓰레드 종료 상태.</td>
  </tr>
</tbody>
</table>
<br>

  - **쓰레드의 일시정지 상태** : `BLOCKED`, `WAITING`, `TIMED_WAITING`
<table>
<thead>
  <tr>
    <th colspan="2">상태</th>
    <th>설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Waiting</td>
    <td rowspan="3">일시 정지</td>
    <td>대기 상태.</td>
  </tr>
  <tr>
    <td>Timed-Waiting</td>
    <td>일정 시간 동안 대기 상태.</td>
  </tr>
  <tr>
    <td>Blocked</td>
    <td>락 동안 대기 상태.</td>
  </tr>
</tbody>
</table>
<br>

  #### 쓰레드의 생명주기
  **상태 New (생성)**
  - 쓰레드 객체를 생성. (객체 생성과 동일)
  - 쓰레드의 생성자는 Runnable 인터페이스를 구현한 객체만 매개변수 전달 가능.
  ```java
  ThreadRobot ThreadR = new ThreadRobot();
  ```
<br>

  **상태 Runnable (준비 및 실행)**
  - 생성한 쓰레드 객체의 `start() 메소드` 호출. (`run()메소드` 실행)

  **For example**
  ```java
  public class ThreadRobot implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
        System.out.println("Robot Thread");
    }
  }

  public class Robot {
    public static void main(String[] args) {
        ThreadRobot ThreadR = new ThreadRobot();

        ThreadR.start();
    }
  }
  ```
  ```
  Thread-0
  Robot Thread
  ```
<br>

  **상태 Terminated (종료)**
  - 실행한 쓰레드의 연산이 종료되면 `쓰레드도 같이 종료`.
<br>


### 쓰레드의 우선순위
---
  - 쓰레드는 우선 순위라는 속성 변수를 보유.
<br>


### Main 쓰레드
---
<br>


### 동기화
---
<br>


### 데드락
---
<br>


___
___
#### REFERENCE
>
