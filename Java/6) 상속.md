# 목표
자바의 상속에 대해서 학습하세요.
<br>

## 학습할 것 (필수)
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스
<br>


### 자바 상속의 특징
---
  #### 상속(Inheritance)
   - 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것.
   - 기존에 정의되어 있는 **클래스(super class)** 의 필드와 메소드를 그대로 **새로운 클래스(sub class)** 에서 물려받아 사용.
> **부모 클래스(super class)** : 자식 클래스에 필드와 메소드를 상속하는 상위 클래스. <br>
> **자식 클래스(sub class)** : 부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스.

  #### Java 상속
   - 기존의 클래스를 재활용하므로 코드의 간결화.
   - 클래스 계층 관계를 구성함으로써 **다형성**의 문법적 토대 마련.
> **다형성(Polymorphism)** : 한 타입의 참조 변수를 통해 여러 타입의 객체를 참조할 수 있도록 하는 것.
   - 클래스 선언문에 **extends** 키워드와 함께 상속할 **부모 클래스명** 작성.
> 자바는 다중 상속 허용X
<br>

  **형태**
  ```java
  class 클래스명 extends 상속할 클래스명 {
    ...
  }
  ```
<br>

  **For example**
  ```java
  public class Robot {              // 부모 클래스
    String Name; 
    int Size;                       // 필드

    public void Print() {        // 메소드
      System.out.println("선언 로봇 :" + name + " " + Size + " M ");
    }
  }

  public class CreateRobot extends Robot {
    CreateRobot (String name, int size) {   // 생성자
      this.Name = name;  
      this.Size = size;                     // CreateRobot가 Robot의 필드를 상속 및 선언
    }

  public class SizeCheck {
    public static void main (String[] args){
      CreateRobot Gipsy = new CreateRobot("Gipsy Danger", 240);
      Gipsy.Print();
    }
  }
  ```

  ```
  선언 로봇 : Gipsy Danger 240M
  ```
<br>


### super 키워드
---
  - 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수.
  - 부모 생성자를 호출하는 키워드.
> 인스턴스 메소드만 대상으로 사용 가능. (클래스 메소드 사용 X)
<br>

  **For example**
  ```java
  public class Robot {
    int Size = 100;
  }

  pubiic class print extends Robot {
    int Size = 200;

    void printsize() {
      System.out.println(Size);
      System.out.println(super.Size);
    }
  }

  public class SizeCheck {
    public static void main(String[] args) {
      print check = new print();
      check.printsize();
    }
  }
  ```

  ```
  200    // 서브 클래스의 값
  100    // 부모 클래스(super) 값
  ```
<br>

  #### super()
   - 부모 클래스의 생성자 호출에 사용.
   - 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 계속 거슬러 올라가며 수행.
<br>

  **형태**
  ```java
  super();
  ```
<br>

  **For example**
  ```java
  public class Robot {
    int Size;
    Robot(int s) {
      Size = s;
    }
  }

  pubiic class print extends Robot {

    print() {
      super(240);
    }

    void printsize() {
      System.out.println(Size);
    }
  }

  public class SizeCheck {
    public static void main(String[] args) {
      print check = new print();
      check.printsize();
    }
  }
  ```

  ```
  240  // super()로 부모 클래스의 메소드 호출 값
  ```
<br>


### 메소드 오버라이딩
---
  - 속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것.
  - 자식 클래스에서 부모 클래스의 메소드를 재정의하여 사용.
  - 메소드의 선언부가 부모 클래스의 메소드와 동일해야 한다.
  - 메소드의 접근제어자를 부모 클래스의 메소드보다 좁은 범위로 설정 불가.
  - 메소드의 예외를 부모 클래스의 메소드보다 넓은 범위로 설정 불가.
> **메소드 오버로딩(overloading)** : 여러가지의 메소드 시그니처 가지는 메소드들을 같은 이름의 메소드명으로 정의하는 것.
<br>

  **For example**
  ```java
  public class Robot {
    String Name; 
    int Size;

    public void Print() {
      System.out.println("선언 로봇 :" + name + " " + Size + " M ");
    }
  }

  public class CreateRobot extends Robot {
    CreateRobot (String name, int size) {
      this.Name = name;  
      this.Size = size;
    }

    @Override
    public void Print() {
      System.out.println("자식 선언 로봇 :" + name + " " + Size + " M ");  // 메소드 오버라이딩
    }
  }

  public class SizeCheck {
    public static void main (String[] args){
      CreateRobot Gipsy = new CreateRobot("Gipsy Danger", 240);
      Gipsy.Print();
    }
  }
  ```

  ```
  자식 선언 로봇 : Gipsy Danger 240M  // 자식 클래스에 오버라이딩이 되어 있기 때문에 자식 클래스의 메소드 실행
  ```
<br>


### 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
---
  #### 메소드 디스패치(Method Dispatch)
   - A
<br>

  #### static
<br>

  #### Dynamic Dispatch
<br>


### 추상 클래스
---
  - 메소드와 내용이 추상적이기 때문에 객체를 생성할 수 없는 클래스.
  - 객체를 생성하는 클래스들 간의 공통적인 부분을 추출하여 모아놓은 클래스.
  - 클래스명 앞에 `abstract` 키워드를 함께 선언.
  - 실체클래스와 상속 관계를 지닌다. (추상 클래스가 super class - 실체클래스가 sub class)
> **Why use?** <br><br>
> 객체를 생성하는 클래스를 `실체클래스`라고 명칭한다. <br><br>
> 몇몇의 실체클래스가 비슷한 카테고리의 객체를 생성하는 경우 공통된 필드와 메소드를 따로 추출하여 `추상클래스`를 생성해놓으면,<br> 유지보수성이 용이해진다.
<br>

  **형태**
  ```java
  public abstract class 클래스명 {
    // 필드
    // 생성자
    // 메소드
    // 추상메소드
  }
  ```
<br>

  **For example**
  ```java
  public abstract class Robot {       // 'abstract' 키워드를 통해 추상클래스임을 명시.
    String Name; 
    int Size;

    public void Print() {
      System.out.println("선언 로봇 :" + name + " " + Size + " M ");
    }

    public abstract void occupant();  // 추상 메소드
  }
  ```
<br>

  #### 추상 메소드
   - 추상 클래스를 상속하는 자식 클래스에서 반드시 오버라이딩하여 사용해야 하는 추상 클래스의 메소드.
   - 메소드 명 앞에 `abstract` 키워드를 함께 명시함으로 추상 메소드 선언.

  **For example**
  ```java
  // super class
  public abstract class Robot {       // 'abstract' 키워드를 통해 추상클래스임을 명시.
    String Name; 
    int Size;

    public void Print() {
      System.out.println("선언 로봇 :" + name + " " + Size + " M ");
    }

    public abstract void occupant();  // 추상 메소드
  }
  ```

  ```java
  // sub class
  public class small extends Robot {
    CreateRobot (String name, int size) {
      this.Name = name;  
      this.Size = size;
    }

    @Override
    public void occupant() {
      System.out.println("SeungTae");  // 추상 메소드 오버라이딩 (반드시 재정의 해야한다.)
    }
  }
  ```
<br>


### final 키워드
---
<br>


### Object 클래스
---
  - 모든 클래스의 부모 클래스가 되는 클래스.
  - 
<br>


___
___
#### REFERENCE
> 
